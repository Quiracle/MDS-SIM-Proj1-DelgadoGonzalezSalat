---
title: "Test"
output: html_document
date: "2024-09-30"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
if(!is.null(dev.list())) dev.off() # Clear plots in case these are present
rm(list=ls()) # Remove all variables that are in the current workspace
```

##Data preparation

First, the data was imported and sampled as asked to. 

```{r}
library(readr)
train <- read_csv("train.csv")
```

```{r}
head(train)
```
We need some information about the data to start making decisions about how deal with the problem.


```{r}
summary(train)
train$binnedinc <- factor(train$binnedinc)
train$geography <- factor(train$geography)
```
In the summary, it can be notice that in the variable "pctsomecol18_24" shows a great percentage of missing values. According with the information of the project, the variable corresponds with "Percent of county residents ages 18-24 highest education attained: some college" so it should be decided what to do with the variable.

```{r}
str(train)
```
This checks the type of each variable 
```{r}
# Some plots are done:
boxplot(train$percentmarried)
boxplot(train$pctmarriedhouseholds)
```

```{r}
varout <- summary(train$pctmarriedhouseholds)

# Interquartile range calculation:
iqr <- varout[5] - varout[2]

umout <- varout[5] + 1.5*iqr # Upper extreme for mild outliers
usout <- varout[5] + 3*iqr # Upper extreme for extreme outliersm (iqr = inter quartile range)
boxplot(train$percentmarried, horizontal = TRUE)
boxplot(train$pctmarriedhouseholds, horizontal = TRUE)
abline(v = umout, col = "orange", lwd = 2)
abline(v = usout, col = "red", lwd = 2)
```

```{r}
plot(train[,c(14,32)])
```

```{r}
cor(train[,1:8])
```

# Determine if the response variable (deathrate) has an acceptably normal distribution.

It is not normally distributed
```{r}
hist(train$target_deathrate, breaks = 15, freq = FALSE, col="cyan")
curve(dnorm(x, mean(train$target_deathrate), sd(train$target_deathrate)), add = TRUE)
```

```{r}
shapiro.test(train$target_deathrate)
```

# Address tests to discard serial correlation.

using acf we can see there is autocorrelation, so we randomize the dataframe to get rid of it.
```{r}
acf(train$target_deathrate)
```

```{r}
ll <- sample(1:nrow(train),nrow(train))
train <- train[ll,]
acf(train$target_deathrate)
```

# Detect univariant and multivariant outliers and retain all of them in exploratory analysis.

```{r}
sum <- summary(train$avganncount)
iqr <- sum[5] - sum[2]
lmout <- sum[2] - 1.5*iqr
umout <- sum[5] + 1.5*iqr
lsout <- sum[2] - 3*iqr
usout <- sum[5] + 3*iqr
boxplot(train$avganncount, horizontal = TRUE)
abline(v = umout, col = "orange", lwd = 2)
abline(v = usout, col = "red", lwd = 2)
abline(v = lmout, col = "orange", lwd = 2)
abline(v = lsout, col = "red", lwd = 2)
sevout <- which(train$avganncount > usout); sevout
```

```{r}
sum <- summary(train$avgdeathsperyear)
iqr <- sum[5] - sum[2]
lmout <- sum[2] - 1.5*iqr
umout <- sum[5] + 1.5*iqr
lsout <- sum[2] - 3*iqr
usout <- sum[5] + 3*iqr
boxplot(train$avgdeathsperyear, horizontal = TRUE)
abline(v = umout, col = "orange", lwd = 2)
abline(v = usout, col = "red", lwd = 2)
abline(v = lmout, col = "orange", lwd = 2)
abline(v = lsout, col = "red", lwd = 2)
sevout <- which(train$avgdeathsperyear > usout); sevout
```

```{r}
sum <- summary(train$povertypercent)
iqr <- sum[5] - sum[2]
lmout <- sum[2] - 1.5*iqr
umout <- sum[5] + 1.5*iqr
lsout <- sum[2] - 3*iqr
usout <- sum[5] + 3*iqr
boxplot(train$povertypercent, horizontal = TRUE)
abline(v = umout, col = "orange", lwd = 2)
abline(v = usout, col = "red", lwd = 2)
abline(v = lmout, col = "orange", lwd = 2)
abline(v = lsout, col = "red", lwd = 2)
sevout <- which(train$povertypercent > usout); sevout
```

```{r}
sum <- summary(train$pctunemployed16_over)
iqr <- sum[5] - sum[2]
lmout <- sum[2] - 1.5*iqr
umout <- sum[5] + 1.5*iqr
lsout <- sum[2] - 3*iqr
usout <- sum[5] + 3*iqr
boxplot(train$pctunemployed16_over, horizontal = TRUE)
abline(v = umout, col = "orange", lwd = 2)
abline(v = usout, col = "red", lwd = 2)
abline(v = lmout, col = "orange", lwd = 2)
abline(v = lsout, col = "red", lwd = 2)
sevout <- which(train$pctunemployed16_over > usout); sevout
```

```{r}
library(chemometrics)
res.mout <- Moutlier(train[,1:4], quantile = 0.995)
```

```{r}
plot(res.mout$md, res.mout$rd, col= "cyan", pch = 19)
abline(h=res.mout$cutoff, col = "red")
abline(v=res.mout$cutoff, col = "red")
text(res.mout$md, res.mout$rd, label = row.names(df), cex = 0.5)
mult_outliers <- which((res.mout$md > res.mout$cutoff) & (res.mout$rd > res.mout$cutoff))
print(mult_outliers)
```

# Errors and missing values (if any) detection. Apply an imputation technique for both train and test datasets, if needed.

We remove pctsomecol18_24, since it has over 70% of NAs.
Using impute PCA for the other two variables (pctemployed16_over and pctprivatecoveragealone) with missing values, we see that the summary of each variable doesn't change meaningfully
```{r}
library(missMDA)
res.misMDA <- imputePCA(train[,c(-17, -9, -13)])

summary(train$pctprivatecoveragealone)
summary(res.misMDA$completeObs[,"pctprivatecoveragealone"])

summary(train$pctemployed16_over)
summary(res.misMDA$completeObs[,"pctemployed16_over"])
```
```{r}
train[,c(-17, -9, -13)] <- res.misMDA$completeObs
train <- train[,-17]
```


```{r}
'''
library(mice)
summary(train)
imputation = mice(train[,-17], method=)
summary(train$pctprivatecoveragealone)
summary(train$pctsomecol18_24)
summary(train$pctemployed16_over)

summary(complete(imputation)$pctprivatecoveragealone)
summary(complete(imputation)$pctsomecol18_24)
summary(complete(imputation)$pctemployed16_over)
'''
```

# Preliminary exploratory analysis to describe observed relations has to be undertaken

To do this, the condes function of the FactoMiner package is used, which for the
numeric response variable ‘target_deathrate’ calculates the correlation of each of the quantitative
variables and the coefficient of determination (R^2) for the qualitative variables,
together with a p-value for significance.

For the quantitative variables it is clear both pctpubliccoveragealone and povertypercent are highly significant positively correlated (r > 0.45, p = 0) to the target. The pctbachdeg25_over, pctemployed16_over and medincome are highly significant negatively correlated to the target (r < -0.44). pctprivatecoverage and pctprivatecoveragealone have a less but also significant negative correlation to the price (r < -0.4, p ~ 0), which makes sense as they are very similar measures. To further illustrate the correlations, a correlation matrix is plotted as well.

For the qualitative variables, we only have binnedinc, which has a low R2 value not explaining too much of the variable.
```{r}
library(FactoMineR)

res.con <- condes(train[,c(1:12,14:31)], 3)
res.con$quanti
res.con$quali
```

